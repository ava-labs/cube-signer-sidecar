{
  "components": {
    "responses": {
      "KeyInfo": {
        "content": {
          "application/json": {
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/CommonFields"
                },
                {
                  "properties": {
                    "derivation_info": {
                      "allOf": [
                        {
                          "$ref": "#/components/schemas/KeyDerivationInfo"
                        }
                      ],
                      "nullable": true
                    },
                    "enabled": {
                      "description": "Whether the key is enabled (only enabled keys may be used for signing)",
                      "type": "boolean"
                    },
                    "key_id": {
                      "description": "The id of the key: \"Key#\" followed by a unique identifier specific to\nthe type of key (such as a public key for BLS or an ethereum address for Secp)",
                      "example": "Key#0x8e3484687e66cdd26cf04c3647633ab4f3570148",
                      "type": "string"
                    },
                    "key_type": {
                      "$ref": "#/components/schemas/KeyType"
                    },
                    "material_id": {
                      "description": "A unique identifier specific to the type of key, such as a public key or an ethereum address",
                      "example": "0x8e3484687e66cdd26cf04c3647633ab4f3570148",
                      "type": "string"
                    },
                    "owner": {
                      "description": "Owner of the key",
                      "example": "User#c3b9379c-4e8c-4216-bd0a-65ace53cf98f",
                      "type": "string"
                    },
                    "policy": {
                      "description": "Key policy",
                      "example": [
                        "AllowRawBlobSigning",
                        {
                          "RequireMfa": {
                            "count": 1
                          }
                        }
                      ],
                      "items": {},
                      "type": "array"
                    },
                    "public_key": {
                      "description": "Hex-encoded, serialized public key. The format used depends on the key type:\n- Secp256k1 keys use 65-byte uncompressed SECG format;\n- Stark keys use 33-byte compressed SECG format;\n- BLS keys use 48-byte compressed BLS12-381 (ZCash) format;\n- Ed25519 keys use the canonical 32-byte encoding specified in RFC 8032.",
                      "example": "0x04d2688b6bc2ce7f9879b9e745f3c4dc177908c5cef0c1b64cff19ae7ff27dee623c64fe9d9c325c7fbbc748bbd5f607ce14dd83e28ebbbb7d3e7f2ffb70a79431",
                      "type": "string"
                    },
                    "purpose": {
                      "description": "The purpose for which the key can be used (e.g., chain id for which the key is allowed to sign messages)",
                      "example": "Eth2Validator(1)",
                      "type": "string"
                    }
                  },
                  "required": [
                    "key_type",
                    "key_id",
                    "material_id",
                    "purpose",
                    "enabled",
                    "owner",
                    "public_key",
                    "policy"
                  ],
                  "type": "object"
                }
              ]
            }
          }
        },
        "description": ""
      },
      "NewSessionResponse": {
        "content": {
          "application/json": {
            "schema": {
              "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).",
              "properties": {
                "expiration": {
                  "description": "Session expiration (in seconds since UNIX epoch), beyond which it cannot be refreshed.",
                  "example": 1701879640,
                  "format": "int64",
                  "minimum": 0,
                  "type": "integer"
                },
                "org_id": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/Id"
                    }
                  ],
                  "nullable": true
                },
                "refresh_token": {
                  "description": "Token that can be used to refresh this session.",
                  "type": "string"
                },
                "session_info": {
                  "$ref": "#/components/schemas/ClientSessionInfo"
                },
                "token": {
                  "description": "New token to be used for authentication. Requests to signing endpoints\nshould include this value in the `Authorization` header.",
                  "type": "string"
                }
              },
              "required": [
                "token",
                "refresh_token",
                "session_info"
              ],
              "type": "object"
            }
          }
        },
        "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.)."
      },
      "SignResponse": {
        "content": {
          "application/json": {
            "schema": {
              "properties": {
                "signature": {
                  "description": "The hex-encoded resulting signature.",
                  "type": "string"
                }
              },
              "required": [
                "signature"
              ],
              "type": "object"
            }
          }
        },
        "description": ""
      }
    },
    "schemas": {
      "AcceptedResponse": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ErrorResponse"
          },
          {
            "type": "object"
          }
        ]
      },
      "AcceptedValue": {
        "description": "Different responses we return for status code \"202 Accepted\".\n\nEven though \"202 Accepted\" is a successful response, we represent\nit as a Rust error because that makes it easy to have route handlers\nreturn `Result\u003cT, SignerError\u003e` where `T` is the type of the\nresponse for the status code \"200 Ok\".",
        "oneOf": [
          {
            "properties": {
              "MfaRequired": {
                "properties": {
                  "id": {
                    "description": "Always set to first MFA id from `Self::ids`",
                    "type": "string"
                  },
                  "ids": {
                    "description": "Non-empty MFA request IDs",
                    "items": {
                      "minLength": 1,
                      "type": "string"
                    },
                    "type": "array"
                  },
                  "org_id": {
                    "description": "Organization id",
                    "type": "string"
                  },
                  "session": {
                    "allOf": [
                      {
                        "$ref": "#/components/schemas/NewSessionResponse"
                      }
                    ],
                    "nullable": true
                  }
                },
                "required": [
                  "id",
                  "ids",
                  "org_id"
                ],
                "type": "object"
              }
            },
            "required": [
              "MfaRequired"
            ],
            "type": "object"
          }
        ]
      },
      "AcceptedValueCode": {
        "enum": [
          "MfaRequired"
        ],
        "type": "string"
      },
      "AuthData": {
        "description": "Data required for both `authenticate` and `refresh`.",
        "properties": {
          "epoch_num": {
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "epoch_token": {
            "$ref": "#/components/schemas/B32"
          },
          "other_token": {
            "type": "string"
          }
        },
        "required": [
          "epoch_num",
          "epoch_token",
          "other_token"
        ],
        "type": "object"
      },
      "B32": {
        "description": "Wrapper around a zeroizing 32-byte fixed-size array",
        "type": "string"
      },
      "BadGatewayErrorCode": {
        "enum": [
          "EsploraApiError",
          "SentryApiError",
          "CallWebhookError",
          "OAuthProviderError",
          "OidcDisoveryFailed",
          "OidcIssuerJwkEndpointUnavailable",
          "SmtpServerUnavailable"
        ],
        "type": "string"
      },
      "BadRequestErrorCode": {
        "enum": [
          "GenericBadRequest",
          "InvalidPaginationToken",
          "InvalidEmail",
          "InvalidEmailTemplate",
          "QueryMetricsError",
          "InvalidTelegramData",
          "QueryMetricsValidationError",
          "WebhookPolicyTimeoutOutOfBounds",
          "WebhookPolicyDisallowedUrlScheme",
          "WebhookPolicyDisallowedUrlHost",
          "WebhookPolicyDisallowedHeaders",
          "ReservedName",
          "UserEmailNotConfigured",
          "EmailPasswordNotFound",
          "PasswordAuthNotAllowedByInvitation",
          "OneTimeCodeExpired",
          "InvalidBody",
          "InvalidJwt",
          "InvitationNoLongerValid",
          "TokenRequestError",
          "InvalidMfaReceipt",
          "InvalidMfaPolicyCount",
          "InvalidMfaPolicyNumAuthFactors",
          "InvalidMfaPolicyNumAllowedApprovers",
          "InvalidMfaPolicyGracePeriodTooLong",
          "InvalidBabylonStakingPolicyParams",
          "InvalidSuiTxReceiversEmptyAllowlist",
          "InvalidBtcTxReceiversEmptyAllowlist",
          "InvalidRequireRoleSessionAllowlist",
          "InvalidCreateKeyCount",
          "OrgInviteExistingUser",
          "OrgUserAlreadyExists",
          "OrgNameTaken",
          "OrgIsNotOrgExport",
          "RoleNameTaken",
          "PolicyNameTaken",
          "NameTaken",
          "ContactNameInvalid",
          "InvalidBtcAddressForChain",
          "PolicyNotFound",
          "PolicyVersionNotFound",
          "PolicyRuleDisallowedByType",
          "PolicyTypeDisallowed",
          "PolicyDuplicateError",
          "PolicyStillAttached",
          "PolicyModified",
          "PolicyNotAttached",
          "AddKeyToRoleCountTooHigh",
          "InvalidKeyId",
          "InvalidTimeLockAlreadyInThePast",
          "InvalidRestrictedScopes",
          "InvalidUpdate",
          "InvalidMetadataLength",
          "InvalidLength",
          "InvalidKeyMaterialId",
          "KeyNotFound",
          "SiweChallengeNotFound",
          "SiweInvalidRequest",
          "UserExportDerivedKey",
          "UserExportPublicKeyInvalid",
          "UnableToAccessSmtpRelay",
          "UserExportInProgress",
          "RoleNotFound",
          "InvalidRoleNameOrId",
          "InvalidMfaReceiptOrgIdMissing",
          "InvalidMfaReceiptInvalidOrgId",
          "MfaRequestNotFound",
          "InvalidKeyType",
          "InvalidKeyMaterial",
          "InvalidHexValue",
          "InvalidBase32Value",
          "InvalidBase58Value",
          "InvalidSs58Value",
          "InvalidForkVersionLength",
          "InvalidEthAddress",
          "InvalidStellarAddress",
          "InvalidOrgNameOrId",
          "InvalidUpdateOrgRequestDisallowedMfaType",
          "InvalidUpdateOrgRequestEmptyAllowedMfaTypes",
          "EmailOtpDelayTooShortForRegisterMfa",
          "InvalidStakeDeposit",
          "InvalidBlobSignRequest",
          "InvalidSolanaSignRequest",
          "InvalidEip712SignRequest",
          "OnlySpecifyOne",
          "NoOidcDataInProof",
          "InvalidEvmSignRequest",
          "InvalidEth2SignRequest",
          "InvalidDeriveKeyRequest",
          "InvalidStakingAmount",
          "CustomStakingAmountNotAllowedForWrapperContract",
          "InvalidUnstakeRequest",
          "InvalidCreateUserRequest",
          "UserAlreadyExists",
          "IdpUserAlreadyExists",
          "CognitoUserAlreadyOrgMember",
          "UserNotFound",
          "UserWithEmailNotFound",
          "PolicyKeyMismatch",
          "PolicyRuleKeyMismatch",
          "EmptyScopes",
          "InvalidScopesForRoleSession",
          "InvalidLifetime",
          "NoSingleKeyForUser",
          "InvalidOrgPolicyRule",
          "SourceIpAllowlistEmpty",
          "LimitWindowTooLong",
          "Erc20ContractDisallowed",
          "EmptyRuleError",
          "OptionalListEmpty",
          "DuplicateFieldEntry",
          "InvalidRange",
          "InvalidOrgPolicyRepeatedRule",
          "InvalidSuiTransaction",
          "SuiSenderMismatch",
          "AvaSignHashError",
          "AvaSignError",
          "BtcSegwitHashError",
          "BtcTaprootHashError",
          "BtcSignError",
          "TaprootSignError",
          "Eip712SignError",
          "InvalidMemberRoleInUserAdd",
          "InvalidMemberRoleInRecipientAdd",
          "ThirdPartyUserAlreadyExists",
          "OidcIdentityAlreadyExists",
          "ThirdPartyUserNotFound",
          "DeleteOidcUserError",
          "DeleteUserError",
          "SessionRoleMismatch",
          "InvalidOidcToken",
          "InvalidOidcIdentity",
          "OidcIssuerUnsupported",
          "OidcIssuerNotAllowed",
          "OidcIssuerNoApplicableJwk",
          "FidoKeyAlreadyRegistered",
          "FidoKeySignCountTooLow",
          "FidoVerificationFailed",
          "FidoChallengeMfaMismatch",
          "UnsupportedLegacyCognitoSession",
          "InvalidIdentityProof",
          "PaginationDataExpired",
          "ExistingKeysViolateExclusiveKeyAccess",
          "ExportDelayTooShort",
          "ExportWindowTooLong",
          "InvalidTotpFailureLimit",
          "InvalidEip191SignRequest",
          "CannotResendUserInvitation",
          "InvalidNotificationEndpointCount",
          "CannotDeletePendingSubscription",
          "InvalidNotificationUrlProtocol",
          "EmptyOneOfOrgEventFilter",
          "EmptyAllExceptOrgEventFilter",
          "InvalidTapNodeHash",
          "InvalidOneTimeCode",
          "MessageNotFound",
          "MessageAlreadySigned",
          "MessageRejected",
          "MessageReplaced",
          "InvalidMessageType",
          "EmptyAddress",
          "InvalidEth2SigningPolicySlotRange",
          "InvalidEth2SigningPolicyEpochRange",
          "InvalidEth2SigningPolicyTimestampRange",
          "InvalidEth2SigningPolicyOverlappingRule",
          "MmiRpcUrlMissing",
          "MmiChainIdMissing",
          "EthersInvalidRpcUrl",
          "EthersGetTransactionCountError",
          "InvalidPassword",
          "BabylonStakingFeePlusDustOverflow",
          "BabylonStaking",
          "BabylonStakingIncorrectKey",
          "BabylonStakingSegwitNonDeposit",
          "BabylonStakingRegistrationRequiresTaproot",
          "PsbtSigning",
          "TooManyResets",
          "TooManyRequests",
          "TooManyFailedLogins",
          "BadBtcMessageSignP2shFlag",
          "InvalidTendermintRequest",
          "PolicyVersionMaxReached",
          "PolicyVersionInvalid",
          "AlienOwnerInvalid",
          "EmptyUpdateRequest",
          "InvalidPolicyReference",
          "PolicyEngineDisabled",
          "InvalidWasmPolicy",
          "RedundantDerivationPath",
          "ImportKeyMissing",
          "InvalidAbiMethods",
          "BabylonCovSign",
          "InvalidPolicyLogsRequest",
          "UserProfileMigrationMultipleEntries",
          "UserProfileMigrationTooManyItems"
        ],
        "type": "string"
      },
      "BlobSignRequest": {
        "allOf": [
          {
            "properties": {
              "metadata": {
                "description": "Optional metadata. Passing additional information as metadata can be used to make reviewing\nof pending MFA requests and/or historical key transactions more transparent. It can also be used e.g., to carry additional data to WebHook policies.",
                "nullable": true
              }
            },
            "type": "object"
          },
          {
            "properties": {
              "adaptor_pk": {
                "description": "An optional base64 string comprising a SEC1-encoded secp256k1 public key.\nThis field can be used *only* with Schnorr keys.\n\nIf this field is present, the response will be a Schnorr adaptor signature\nin the format specified by Blockstream for use in libsecp256k1-zkp. See\n\u003chttps://github.com/ZhePang/Python_Specification_for_Schnorr_Adaptor/\u003e\nfor more information.",
                "example": "Arny4WoHDNBVXYcynhNl9/y7JttJ2rk0CCRfLR7t3aDg",
                "nullable": true,
                "type": "string"
              },
              "bls_dst": {
                "description": "An optional domain separation tag for use *only* with BLS signing requests.\nThis field must not be supplied for requests involving non-BLS key types.\n\nIf this field is not present or null, the domain separation tag specified in\nthe IETF BLS Signatures draft versions 4 and 5, section 4.2.3 (minimal pubkey\nsize variant) is used.\n\nOtherwise, this field must contain a base-64 string encoding a non-empty byte\nvector. When using a custom tag, RFC9380 (Section 3.1) recommends a length of\nat least 16 bytes.",
                "example": "EbbLvCxI7gan71iISDsfr46etOv606QkGGDP5PpVl5Q=",
                "nullable": true,
                "type": "string"
              },
              "message_base64": {
                "description": "The blob to sign, encoded as a base64 string.\n\nNote that certain signing keys impose additional requirements on the contents of\nthe message. For example, Secp256k1 keys require that the message is 32 bytes long.",
                "type": "string"
              },
              "segwit_tweak": {
                "description": "An optional tweak value for use *only* with Segwit (i.e., SecpBtc and SecpBtcTest)\nkeys. This field must not be supplied for requests involving any other key type.\n\nIf this field is not present or null, no tweak is applied. Otherwise, this field\nmust contain a base-64 string encoding a vector of exactly 32 bytes. See the\nCubeSigner documentation for more information on the Segwit tweaking procedure.",
                "example": "F41HAy2q5Gn8laF2CuMsZbRAQTmD+4Ob3VUMZ7TBGK4=",
                "nullable": true,
                "type": "string"
              },
              "taproot_tweak": {
                "description": "An optional tweak value for use *only* with Taproot keys. This field must not\nbe supplied for requests involving any other key type.\n\nIf this field is not present or null, no tweak is applied. If the field is an\nempty string, the key is tweaked with an unspendable script path per BIP0341.\nOtherwise, this field must contain a 32-byte, base-64 string representing the\nMerkle root with which to tweak the key before signing.",
                "example": "F41HAy2q5Gn8laF2CuMsZbRAQTmD+4Ob3VUMZ7TBGK4=",
                "nullable": true,
                "type": "string"
              }
            },
            "required": [
              "message_base64"
            ],
            "type": "object"
          }
        ],
        "example": {
          "message_base64": "YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTYK"
        }
      },
      "ClientProfile": {
        "description": "Client information representing the nature of front-end in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`].",
        "properties": {
          "agent": {
            "description": "Agent/Product name",
            "example": "Mozilla Firefox",
            "nullable": true,
            "type": "string"
          },
          "engine": {
            "description": "Name of the engine",
            "example": "Gecko",
            "nullable": true,
            "type": "string"
          },
          "version": {
            "description": "Agent/product version",
            "example": "41.2",
            "nullable": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "ClientSessionInfo": {
        "description": "Session information sent to the client.\nThis struct works in tandem with its server-side counterpart [`SessionData`].",
        "properties": {
          "auth_token": {
            "description": "Token to use for authorization.",
            "type": "string"
          },
          "auth_token_exp": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "epoch": {
            "description": "Epoch at which the token was last refreshed",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "epoch_token": {
            "$ref": "#/components/schemas/B32"
          },
          "refresh_token": {
            "description": "Token to use for refreshing the `(auth, refresh)` token pair",
            "type": "string"
          },
          "refresh_token_exp": {
            "$ref": "#/components/schemas/EpochDateTime"
          },
          "session_id": {
            "description": "Session ID",
            "type": "string"
          }
        },
        "required": [
          "session_id",
          "auth_token",
          "refresh_token",
          "epoch",
          "epoch_token",
          "auth_token_exp",
          "refresh_token_exp"
        ],
        "type": "object"
      },
      "ClientSessionMetadata": {
        "description": "Attributes that are expected to be provided by the client",
        "properties": {
          "client": {
            "$ref": "#/components/schemas/ClientProfile"
          },
          "os_info": {
            "$ref": "#/components/schemas/OsInfo"
          }
        },
        "type": "object"
      },
      "CommonFields": {
        "description": "Fields that are common to different types of resources such as keys",
        "properties": {
          "created": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochDateTime"
              }
            ],
            "nullable": true
          },
          "edit_policy": {
            "$ref": "#/components/schemas/EditPolicy"
          },
          "last_modified": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochDateTime"
              }
            ],
            "nullable": true
          },
          "metadata": {
            "description": "User-defined metadata. When rendering (e.g., in the browser) you should treat\nit as untrusted user data (and avoid injecting metadata into HTML directly) if\nuntrusted users can create/update keys (or their metadata)."
          },
          "version": {
            "description": "Version of this object",
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "ConflictErrorCode": {
        "enum": [
          "ConcurrentRequestDisallowed",
          "ConcurrentLockCreation"
        ],
        "type": "string"
      },
      "CreateTokenRequest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RatchetConfig"
          },
          {
            "$ref": "#/components/schemas/ClientSessionMetadata"
          },
          {
            "properties": {
              "purpose": {
                "description": "A human readable description of the purpose of the key",
                "example": "Validator Signing",
                "type": "string"
              },
              "scopes": {
                "description": "Controls what capabilities this session will have. By default, it has all\nsigning capabilities, i.e., just the 'sign:*' scope.",
                "example": [
                  "sign:*"
                ],
                "items": {
                  "$ref": "#/components/schemas/Scope"
                },
                "minItems": 1,
                "nullable": true,
                "type": "array"
              }
            },
            "required": [
              "purpose"
            ],
            "type": "object"
          }
        ]
      },
      "EditPolicy": {
        "description": "A policy which governs when and who is allowed to update the entity this policy is\nattached to (e.g., a role or a key).\n\nWhen attached to a role, by default, this policy applies to role deletion and all\nrole updates (including adding/removing keys and users); in terms of scopes,\nit applies to `manage:role:update:*` and `manage:role:delete`.\n\nWhen attached to a key, by default, this policy applies to key deletion, all\nkey updates, and adding/removing that key to/from a role; in terms of scopes,\nit applies to `manage:key:update:*`, `manage:key:delete`, `manage:role:update:key:*`.\n\nThis default can be changed by setting the `applies_to_scopes` property.",
        "properties": {
          "applies_to_scopes": {
            "$ref": "#/components/schemas/ScopeSet"
          },
          "mfa": {
            "allOf": [
              {
                "$ref": "#/components/schemas/MfaPolicy"
              }
            ],
            "nullable": true
          },
          "time_lock_until": {
            "allOf": [
              {
                "$ref": "#/components/schemas/EpochDateTime"
              }
            ],
            "nullable": true
          }
        },
        "type": "object"
      },
      "EpochDateTime": {
        "description": "DateTime measured in seconds since unix epoch.\nA wrapper type for serialization that encodes a [`SystemTime`] as a [`u64`]\nrepresenting the number of seconds since [`SystemTime::UNIX_EPOCH`].",
        "format": "int64",
        "minimum": 0,
        "type": "integer"
      },
      "ErrorResponse": {
        "description": "The structure of ErrorResponse must match the response template that AWS uses",
        "properties": {
          "accepted": {
            "allOf": [
              {
                "$ref": "#/components/schemas/AcceptedValue"
              }
            ],
            "nullable": true
          },
          "error_code": {
            "$ref": "#/components/schemas/SignerErrorCode"
          },
          "message": {
            "description": "Error message",
            "type": "string"
          },
          "request_id": {
            "description": "Optional request identifier",
            "type": "string"
          }
        },
        "required": [
          "message",
          "error_code"
        ],
        "type": "object"
      },
      "EvmTxCmp": {
        "properties": {
          "grace": {
            "description": "To prevent replay attacks, any given MFA receipt is normally allowed to be used only once.\n\nIn this case, however, because EVM transactions already have a replay prevention mechanism\n(namely the 'nonce' property), we allow the user to specify a grace period (in seconds) to\nindicate how long an MFA receipt should remain valid after its first use.\n\nNote that we allow both 'grace' and 'ignore_nonce' to be set because once an MFA request\nenters its grace period we unconditionally set its 'ignore_nonce' property to 'false' to\nensure that any subsequent requests that claim the same receipt must sign for the same\nnonce as the request we signed originally with that receipt.\n\nAlso note that the grace period cannot extend the lifetime of an MFA request beyond its\noriginal expiration date.\n\nThe grace period must not be greater than 30 days.",
            "format": "int64",
            "minimum": 0,
            "nullable": true,
            "type": "integer"
          },
          "ignore_gas": {
            "description": "Whether the 'gas' property of the EVM transaction is allowed to be different.",
            "type": "boolean"
          },
          "ignore_nonce": {
            "description": "Whether the 'nonce' property of the EVM transaction is allowed to be different.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "EvmTxDepositErrorCode": {
        "enum": [
          "EvmTxDepositReceiverMismatch",
          "EvmTxDepositEmptyData",
          "EvmTxDepositEmptyChainId",
          "EvmTxDepositEmptyReceiver",
          "EvmTxDepositUnexpectedValue",
          "EvmTxDepositUnexpectedDataLength",
          "EvmTxDepositNoAbi",
          "EvmTxDepositNoDepositFunction",
          "EvmTxDepositUnexpectedFunctionName",
          "EvmTxDepositUnexpectedValidatorKey",
          "EvmTxDepositInvalidValidatorKey",
          "EvmTxDepositMissingDepositArg",
          "EvmTxDepositWrongDepositArgType",
          "EvmTxDepositValidatorKeyNotInRole",
          "EvmTxDepositUnexpectedWithdrawalCredentials",
          "EvmTxDepositUnresolvedRole",
          "EvmTxDepositInvalidDepositEncoding"
        ],
        "type": "string"
      },
      "ForbiddenErrorCode": {
        "enum": [
          "CannotAssumeIdentity",
          "SentryDisallowed",
          "PasskeyLoginDisabled",
          "PasskeyNotRegistered",
          "CannotCreateOrg",
          "WrongMfaEmailOtpJwt",
          "OrgFlagNotSet",
          "FidoRequiredToRemoveTotp",
          "OidcIdentityLimitReached",
          "OidcScopeCeilingMissing",
          "OidcIssuerNotAllowedForMemberRole",
          "OidcNoMemberRolesAllowed",
          "EmailOtpNotConfigured",
          "MfaChallengeExpired",
          "ChainIdNotAllowed",
          "InvalidOrg",
          "OrgIdMismatch",
          "SessionForWrongOrg",
          "SelfDelete",
          "SelfDisable",
          "InvalidOrgMembershipRoleChange",
          "UserDisabled",
          "OrgDisabled",
          "OrgNotFound",
          "OrgWithoutOwner",
          "OrphanedUser",
          "OidcUserNotFound",
          "UserNotInOrg",
          "UserNotOrgOwner",
          "UserNotKeyOwner",
          "InvalidRole",
          "DisabledRole",
          "KeyDisabled",
          "KeyNotInRole",
          "ContactNotInOrg",
          "UserExportRequestNotInOrg",
          "UserExportRequestInvalid",
          "UserExportDisabled",
          "UserNotOriginalKeyOwner",
          "UserNotInRole",
          "MustBeFullMember",
          "SessionExpired",
          "SessionChanged",
          "SessionRevoked",
          "ExpectedUserSession",
          "SessionRoleChanged",
          "ScopedNameNotFound",
          "SessionInvalidEpochToken",
          "SessionInvalidRefreshToken",
          "SessionRefreshTokenExpired",
          "InvalidAuthHeader",
          "SessionNotFound",
          "InvalidArn",
          "SessionInvalidAuthToken",
          "SessionAuthTokenExpired",
          "SessionPossiblyStolenToken",
          "MfaDisallowedIdentity",
          "MfaDisallowedApprover",
          "MfaTypeNotAllowed",
          "MfaNotApprovedYet",
          "MfaConfirmationCodeMismatch",
          "MfaHttpRequestMismatch",
          "MfaRemoveBelowMin",
          "MfaOrgRequirementNotMet",
          "MfaRegistrationDisallowed",
          "TotpAlreadyConfigured",
          "TotpConfigurationChanged",
          "MfaTotpBadConfiguration",
          "MfaTotpBadCode",
          "MfaTotpRateLimit",
          "ImproperSessionScope",
          "FullSessionRequired",
          "SessionWithoutAnyScopeUnder",
          "UserRoleUnprivileged",
          "MemberRoleForbidden",
          "MfaNotConfigured",
          "RemoveLastOidcIdentity",
          "OperationNotAllowed",
          "OrgExportRetrievalDisabled",
          "AutoAddBlsKeyToProtectedRole",
          "UserNotPolicyOwner",
          "UserNotContactOwner",
          "LegacySessionCannotHaveScopeCeiling",
          "RoleInParentOrgNotAllowed",
          "RemoveKeyFromRoleUserNotAllowed",
          "SiweChallengeExpired",
          "SiweMessageNotValid",
          "SiweMessageInvalidSignature"
        ],
        "type": "string"
      },
      "HttpRequestCmp": {
        "description": "How to compare HTTP requests when verifying MFA receipt (see [MfaRequest::verify_request])",
        "oneOf": [
          {
            "description": "The requests must match exactly. Any given MFA receipt can be used at most once.",
            "enum": [
              "Eq"
            ],
            "type": "string"
          },
          {
            "properties": {
              "EvmTx": {
                "$ref": "#/components/schemas/EvmTxCmp"
              }
            },
            "required": [
              "EvmTx"
            ],
            "type": "object"
          },
          {
            "properties": {
              "SolanaTx": {
                "$ref": "#/components/schemas/SolanaTxCmp"
              }
            },
            "required": [
              "SolanaTx"
            ],
            "type": "object"
          }
        ]
      },
      "Id": {
        "type": "string"
      },
      "InternalErrorCode": {
        "enum": [
          "NoMaterialId",
          "FidoKeyAssociatedWithMultipleUsers",
          "ClaimsParseError",
          "InvalidThrottleId",
          "InvalidEmailAddress",
          "EmailTemplateRender",
          "OidcIdentityHeaderMissing",
          "OidcIdentityParseError",
          "SystemTimeError",
          "PasswordHashParseError",
          "SendMailError",
          "ReqwestError",
          "EmailConstructionError",
          "TsWriteError",
          "TsQueryError",
          "DbQueryError",
          "DbGetError",
          "DbDeleteError",
          "DbPutError",
          "DbUpdateError",
          "SerdeError",
          "TestAndSetError",
          "DbGetItemsError",
          "DbWriteError",
          "CubistSignerError",
          "CwListMetricsError",
          "CwPutMetricDataError",
          "GetAwsSecretError",
          "SecretNotFound",
          "KmsGenerateRandomError",
          "MalformedTotpBytes",
          "KmsGenerateRandomNoResponseError",
          "CreateKeyError",
          "ParseDerivationPathError",
          "SplitSignerError",
          "CreateImportKeyError",
          "CreateEotsNoncesError",
          "EotsSignError",
          "BabylonCovSignError",
          "CognitoDeleteUserError",
          "CognitoListUsersError",
          "CognitoGetUserError",
          "MissingUserEmail",
          "CognitoResendUserInvitation",
          "CognitoSetUserPasswordError",
          "GenericInternalError",
          "OidcAuthWithoutOrg",
          "MissingKeyMetadata",
          "KmsEnableKeyError",
          "KmsDisableKeyError",
          "LambdaInvokeError",
          "LambdaNoResponseError",
          "LambdaFailure",
          "LambdaUnparsableResponse",
          "SerializeEncryptedExportKeyError",
          "DeserializeEncryptedExportKeyError",
          "ReEncryptUserExport",
          "S3UploadError",
          "S3DownloadError",
          "S3CopyError",
          "S3ListObjectsError",
          "S3DeleteObjectsError",
          "S3BuildError",
          "S3PresignedUrlError",
          "ManagedStateMissing",
          "InternalHeaderMissing",
          "InvalidInternalHeaderValue",
          "RequestLocalStateAlreadySet",
          "OidcOrgMismatch",
          "OidcIssuerInvalidJwk",
          "InvalidPkForMaterialId",
          "UncheckedOrg",
          "SessionOrgIdMissing",
          "AvaSignCredsMissing",
          "AvaSignSignatureMissing",
          "ExpectedRoleSession",
          "InvalidThirdPartyIdentity",
          "CognitoGetUser",
          "SnsSubscribeError",
          "SnsUnsubscribeError",
          "SnsGetSubscriptionAttributesError",
          "SnsSubscriptionAttributesMissing",
          "SnsSetSubscriptionAttributesError",
          "SnsPublishBatchError",
          "InconsistentMultiValueTestAndSet",
          "MaterialIdError",
          "InvalidBtcAddress",
          "HistoricalTxBodyMissing",
          "InvalidOperation",
          "ParentOrgNotFound",
          "OrgParentLoop",
          "ResolvedParentOrgWithNoScopeCeiling",
          "InvalidUploadObjectId",
          "PolicyEngineNotFound",
          "PolicyEngineError",
          "PolicySecretsEncryptionError",
          "CreatePolicyImportKeyError",
          "InvalidAlias",
          "EmptyUpdateModifiedObject",
          "EmptyUpdateModifiedActions"
        ],
        "type": "string"
      },
      "KeyDerivationInfo": {
        "description": "Derivation-related metadata for keys derived from a long-lived mnemonic",
        "properties": {
          "derivation_path": {
            "description": "The derivation path used to derive this key",
            "type": "string"
          },
          "mnemonic_id": {
            "description": "The mnemonic-id of the key's parent mnemonic",
            "type": "string"
          }
        },
        "required": [
          "mnemonic_id",
          "derivation_path"
        ],
        "type": "object"
      },
      "KeyType": {
        "enum": [
          "SecpEthAddr",
          "SecpBtc",
          "SecpBtcTest",
          "SecpBtcLegacy",
          "SecpBtcLegacyTest",
          "SecpAvaAddr",
          "SecpAvaTestAddr",
          "BlsPub",
          "BlsInactive",
          "BlsAvaIcm",
          "Ed25519SolanaAddr",
          "Ed25519SuiAddr",
          "Ed25519AptosAddr",
          "Ed25519CardanoAddrVk",
          "Ed25519StellarAddr",
          "Ed25519SubstrateAddr",
          "Mnemonic",
          "Stark",
          "BabylonEots",
          "BabylonCov",
          "TaprootBtc",
          "TaprootBtcTest",
          "SecpCosmosAddr",
          "P256CosmosAddr",
          "P256OntologyAddr",
          "P256Neo3Addr",
          "Ed25519TendermintAddr",
          "SecpTronAddr",
          "Ed25519TonAddr",
          "SecpDogeAddr",
          "SecpDogeTestAddr",
          "SecpKaspaAddr",
          "SecpKaspaTestAddr",
          "SchnorrKaspaAddr",
          "SchnorrKaspaTestAddr",
          "SecpLtc",
          "SecpLtcTest",
          "SecpXrpAddr",
          "Ed25519XrpAddr"
        ],
        "type": "string"
      },
      "MfaPolicy": {
        "example": {
          "allowed_approvers": [
            "User#fabc3f88-04e0-471b-9657-0ae12a3cd73e",
            "User#d796c369-9974-473b-ab9e-e4a2418d2d07"
          ],
          "count": 2,
          "lifetime": 900
        },
        "properties": {
          "allowed_approvers": {
            "description": "Users who are allowed to approve. If empty at creation time, default to the current user.",
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          "allowed_mfa_types": {
            "description": "Allowed approval types. When omitted, defaults to any.",
            "items": {
              "$ref": "#/components/schemas/MfaType"
            },
            "nullable": true,
            "type": "array"
          },
          "count": {
            "description": "How many users to require to approve (defaults to 1).",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "lifetime": {
            "$ref": "#/components/schemas/Seconds"
          },
          "num_auth_factors": {
            "description": "How many auth factors to require per user (defaults to 1).",
            "format": "int32",
            "minimum": 0,
            "type": "integer"
          },
          "request_comparer": {
            "$ref": "#/components/schemas/HttpRequestCmp"
          },
          "restricted_operations": {
            "description": "CubeSigner operations to which this policy should apply.\nWhen omitted, applies to all operations.",
            "items": {
              "$ref": "#/components/schemas/OperationKind"
            },
            "nullable": true,
            "type": "array"
          },
          "time_delay": {
            "$ref": "#/components/schemas/Seconds"
          }
        },
        "type": "object"
      },
      "MfaType": {
        "description": "Different types that can be used to approve an MFA request",
        "format": "'CubeSigner' | 'Fido' | `FidoKey#${string}` | 'Totp' | 'EmailOtp' | `EmailOtp#${number}`",
        "pattern": "^(CubeSigner|Totp|EmailOtp|EmailOtp#\\d+|Fido|FidoKey#[^#\\s]+)$",
        "type": "string"
      },
      "NewSessionResponse": {
        "description": "Information about a new session, returned from multiple endpoints (e.g., login, refresh, etc.).",
        "properties": {
          "expiration": {
            "description": "Session expiration (in seconds since UNIX epoch), beyond which it cannot be refreshed.",
            "example": 1701879640,
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "org_id": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Id"
              }
            ],
            "nullable": true
          },
          "refresh_token": {
            "description": "Token that can be used to refresh this session.",
            "type": "string"
          },
          "session_info": {
            "$ref": "#/components/schemas/ClientSessionInfo"
          },
          "token": {
            "description": "New token to be used for authentication. Requests to signing endpoints\nshould include this value in the `Authorization` header.",
            "type": "string"
          }
        },
        "required": [
          "token",
          "refresh_token",
          "session_info"
        ],
        "type": "object"
      },
      "NotFoundErrorCode": {
        "enum": [
          "UriSegmentMissing",
          "UriSegmentInvalid",
          "TotpNotConfigured",
          "FidoKeyNotFound",
          "FidoChallengeNotFound",
          "TotpChallengeNotFound",
          "UserExportRequestNotFound",
          "UserExportCiphertextNotFound",
          "OrgExportCiphertextNotFound",
          "UploadObjectNotFound",
          "PolicySecretNotFound"
        ],
        "type": "string"
      },
      "OperationKind": {
        "description": "All different kinds of sensitive operations",
        "enum": [
          "AvaSign",
          "AvaChainTxSign",
          "BabylonCovSign",
          "BabylonRegistration",
          "BabylonStaking",
          "BlobSign",
          "BtcMessageSign",
          "BtcSign",
          "PsbtSign",
          "TaprootSign",
          "Eip191Sign",
          "Eip712Sign",
          "EotsNonces",
          "EotsSign",
          "Eth1Sign",
          "Eth2Sign",
          "Eth2Stake",
          "Eth2Unstake",
          "SolanaSign",
          "SuiSign",
          "TendermintSign",
          "RoleUpdate"
        ],
        "type": "string"
      },
      "OsInfo": {
        "description": "OS information set in [`ClientSessionMetadata`] and reflected in [`SessionMetadata`]",
        "properties": {
          "architecture": {
            "example": "arm64",
            "nullable": true,
            "type": "string"
          },
          "name": {
            "example": "Mac OS",
            "nullable": true,
            "type": "string"
          },
          "version": {
            "example": "14.5.0",
            "nullable": true,
            "type": "string"
          },
          "word_size": {
            "example": "64-bit",
            "nullable": true,
            "type": "string"
          }
        },
        "type": "object"
      },
      "PolicyErrorCode": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/PolicyErrorOwnCodes"
          },
          {
            "$ref": "#/components/schemas/EvmTxDepositErrorCode"
          }
        ]
      },
      "PolicyErrorOwnCodes": {
        "enum": [
          "SuiTxReceiversDisallowedTransactionKind",
          "SuiTxReceiversDisallowedTransferAddress",
          "SuiTxReceiversDisallowedCommand",
          "BtcTxDisallowedOutputs",
          "BtcSignatureExceededValue",
          "BtcValueOverflow",
          "BtcSighashTypeDisallowed",
          "EvmTxReceiverMismatch",
          "EvmTxSenderMismatch",
          "EvmTxExceededValue",
          "EvmTxValueUndefined",
          "EvmTxExceededGasCost",
          "EvmTxGasCostUndefined",
          "EvmDataDisallowed",
          "Erc20DataInvalid",
          "EvmContractAddressUndefined",
          "EvmContractChainIdUndefined",
          "EvmDataNotDefined",
          "EvmDataInvalid",
          "EvmContractNotInAllowlist",
          "Erc20ExceededTransferLimit",
          "Erc20ReceiverMismatch",
          "Erc20ExceededApproveLimit",
          "Erc20SpenderMismatch",
          "EvmFunctionNotInAllowlist",
          "EvmFunctionCallInvalid",
          "PolicyDisjunctionError",
          "PolicyNegationError",
          "Eth2ExceededMaxUnstake",
          "Eth2ConcurrentUnstaking",
          "NotInIpv4Allowlist",
          "NotInOriginAllowlist",
          "InvalidSourceIp",
          "RawSigningNotAllowed",
          "Eip712SigningNotAllowed",
          "OidcSourceNotAllowed",
          "NoOidcAuthSourcesDefined",
          "AddKeyToRoleDisallowed",
          "KeysAlreadyInRole",
          "KeyInMultipleRoles",
          "KeyAccessError",
          "RequireRoleSessionKeyAccessError",
          "BtcMessageSigningNotAllowed",
          "Eip191SigningNotAllowed",
          "TaprootSigningDisallowed",
          "SegwitSigningDisallowed",
          "PsbtSigningDisallowed",
          "BabylonStakingDisallowed",
          "TimeLocked",
          "BabylonStakingNetwork",
          "BabylonStakingParamsVersion",
          "BabylonStakingExplicitParams",
          "BabylonStakingStakerPk",
          "BabylonStakingFinalityProviderPk",
          "BabylonStakingLockTime",
          "BabylonStakingValue",
          "BabylonStakingChangeAddress",
          "BabylonStakingFee",
          "BabylonStakingWithdrawalAddress",
          "BabylonStakingBbnAddress",
          "SolanaInstructionCountLow",
          "SolanaInstructionCountHigh",
          "SolanaNotInInstructionAllowlist",
          "SolanaInstructionMismatch",
          "WasmPoliciesDisabled",
          "WasmPolicyDenied",
          "WasmPolicyFailed",
          "WebhookPoliciesDisabled",
          "DeniedByWebhook"
        ],
        "type": "string"
      },
      "PreconditionErrorCode": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/PreconditionErrorOwnCodes"
          },
          {
            "$ref": "#/components/schemas/PolicyErrorCode"
          }
        ]
      },
      "PreconditionErrorOwnCodes": {
        "enum": [
          "Eth2ProposerSlotTooLow",
          "Eth2AttestationSourceEpochTooLow",
          "Eth2AttestationTargetEpochTooLow",
          "Eth2ConcurrentBlockSigning",
          "Eth2ConcurrentAttestationSigning",
          "Eth2MultiDepositToNonGeneratedKey",
          "Eth2MultiDepositUnknownInitialDeposit",
          "Eth2MultiDepositWithdrawalAddressMismatch",
          "ConcurrentSigningWhenTimeLimitPolicyIsDefined",
          "BabylonEotsConcurrentSigning",
          "TendermintStateError",
          "TendermintConcurrentSigning",
          "MfaApprovalsNotYetValid"
        ],
        "type": "string"
      },
      "RatchetConfig": {
        "properties": {
          "auth_lifetime": {
            "default": 300,
            "description": "The lifetime (in seconds) of auth tokens for this session.\nAuth tokens can be refreshed (renewed) using a valid (unexpired)\nrefresh token, but not beyond the session lifetime.",
            "example": 3600,
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "grace_lifetime": {
            "default": 30,
            "description": "The amount of time (in seconds) that an auth token for this session remains\nvalid after it has been refreshed and a new auth token has been issued. This\nhelps to address concurrency hazards, for example, if one thread makes requests\nwith auth token while another refreshes it.",
            "example": 30,
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "refresh_lifetime": {
            "default": 86400,
            "description": "The lifetime (in seconds) of refresh tokens for this session.\nIf this value is shorter than the session lifetime, inactive sessions\nwill become invalid once the auth and refresh tokens have both expired.",
            "example": 43200,
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          },
          "session_lifetime": {
            "default": 31536000,
            "description": "The lifetime (in seconds) of the session.\nThe session cannot be extended beyond its original lifetime.",
            "example": 86400,
            "format": "int64",
            "minimum": 0,
            "type": "integer"
          }
        },
        "type": "object"
      },
      "Scope": {
        "description": "All scopes for accessing CubeSigner APIs",
        "oneOf": [
          {
            "description": "Explicitly named scopes for accessing CubeSigner APIs",
            "enum": [
              "sign:*",
              "sign:ava",
              "sign:blob",
              "sign:btc:*",
              "sign:btc:segwit",
              "sign:btc:taproot",
              "sign:btc:psbt:*",
              "sign:btc:psbt:doge",
              "sign:btc:psbt:legacy",
              "sign:btc:psbt:segwit",
              "sign:btc:psbt:taproot",
              "sign:btc:psbt:ltcSegwit",
              "sign:btc:message:*",
              "sign:btc:message:segwit",
              "sign:btc:message:legacy",
              "sign:babylon:*",
              "sign:babylon:eots:*",
              "sign:babylon:eots:nonces",
              "sign:babylon:eots:sign",
              "sign:babylon:staking:*",
              "sign:babylon:staking:deposit",
              "sign:babylon:staking:unbond",
              "sign:babylon:staking:withdraw",
              "sign:babylon:staking:slash",
              "sign:babylon:registration",
              "sign:babylon:covenant",
              "sign:evm:*",
              "sign:evm:tx",
              "sign:evm:eip191",
              "sign:evm:eip712",
              "sign:eth2:*",
              "sign:eth2:validate",
              "sign:eth2:stake",
              "sign:eth2:unstake",
              "sign:solana",
              "sign:sui",
              "sign:tendermint",
              "sign:mmi",
              "manage:*",
              "manage:readonly",
              "manage:email",
              "manage:mfa:*",
              "manage:mfa:readonly",
              "manage:mfa:list",
              "manage:mfa:vote:*",
              "manage:mfa:vote:cs",
              "manage:mfa:vote:email",
              "manage:mfa:vote:fido",
              "manage:mfa:vote:totp",
              "manage:mfa:register:*",
              "manage:mfa:register:fido",
              "manage:mfa:register:totp",
              "manage:mfa:register:email",
              "manage:mfa:unregister:*",
              "manage:mfa:unregister:fido",
              "manage:mfa:unregister:totp",
              "manage:mfa:verify:*",
              "manage:mfa:verify:totp",
              "manage:key:*",
              "manage:key:readonly",
              "manage:key:get",
              "manage:key:listRoles",
              "manage:key:list",
              "manage:key:history:tx:list",
              "manage:key:create",
              "manage:key:import",
              "manage:key:update:*",
              "manage:key:update:owner",
              "manage:key:update:policy",
              "manage:key:update:enabled",
              "manage:key:update:metadata",
              "manage:key:update:editPolicy",
              "manage:key:delete",
              "manage:policy:*",
              "manage:policy:create",
              "manage:policy:get",
              "manage:policy:list",
              "manage:policy:delete",
              "manage:policy:update:*",
              "manage:policy:update:owner",
              "manage:policy:update:name",
              "manage:policy:update:editPolicy",
              "manage:policy:update:metadata",
              "manage:policy:update:rule",
              "manage:policy:invoke",
              "manage:policy:wasm:*",
              "manage:policy:wasm:upload",
              "manage:policy:secrets:*",
              "manage:policy:secrets:get",
              "manage:policy:secrets:update:*",
              "manage:policy:secrets:update:values",
              "manage:policy:secrets:update:editPolicy",
              "manage:contact:*",
              "manage:contact:create",
              "manage:contact:get",
              "manage:contact:list",
              "manage:contact:delete",
              "manage:contact:update:*",
              "manage:contact:update:name",
              "manage:contact:update:addresses",
              "manage:contact:update:owner",
              "manage:contact:update:metadata",
              "manage:contact:update:editPolicy",
              "manage:policy:createImportKey",
              "manage:role:*",
              "manage:role:readonly",
              "manage:role:create",
              "manage:role:delete",
              "manage:role:get:*",
              "manage:role:get:keys",
              "manage:role:get:keys:list",
              "manage:role:get:keys:get",
              "manage:role:get:users",
              "manage:role:list",
              "manage:role:update:*",
              "manage:role:update:enabled",
              "manage:role:update:policy",
              "manage:role:update:editPolicy",
              "manage:role:update:key:*",
              "manage:role:update:key:add",
              "manage:role:update:key:remove",
              "manage:role:update:user:*",
              "manage:role:update:user:add",
              "manage:role:update:user:remove",
              "manage:role:history:tx:list",
              "manage:identity:*",
              "manage:identity:verify",
              "manage:identity:add",
              "manage:identity:remove",
              "manage:identity:list",
              "manage:org:*",
              "manage:org:create",
              "manage:org:metrics:query",
              "manage:org:readonly",
              "manage:org:addUser",
              "manage:org:inviteUser",
              "manage:org:inviteAlien",
              "manage:org:updateMembership",
              "manage:org:listUsers",
              "manage:org:user:get",
              "manage:org:deleteUser",
              "manage:org:get",
              "manage:session:*",
              "manage:session:readonly",
              "manage:session:get",
              "manage:session:list",
              "manage:session:create",
              "manage:session:extend",
              "manage:session:revoke",
              "manage:export:*",
              "manage:export:org:*",
              "manage:export:org:get",
              "manage:export:user:*",
              "manage:export:user:delete",
              "manage:export:user:list",
              "manage:authMigration:identity:add",
              "manage:authMigration:identity:remove",
              "manage:authMigration:user:update",
              "manage:mmi:*",
              "manage:mmi:readonly",
              "manage:mmi:get",
              "manage:mmi:list",
              "manage:mmi:reject",
              "manage:mmi:delete",
              "export:*",
              "export:user:*",
              "export:user:init",
              "export:user:complete",
              "mmi:*",
              "orgAccess:*",
              "orgAccess:child:*"
            ],
            "title": "ExplicitScopes",
            "type": "string"
          },
          {
            "description": "Scopes including wildcard fragments for accessing CubeSigner APIs",
            "pattern": "^(orgAccess:child)(:[^:]+)?$",
            "title": "OtherScopes",
            "type": "string"
          }
        ]
      },
      "ScopeSet": {
        "description": "A set of scopes.",
        "oneOf": [
          {
            "description": "All scopes",
            "enum": [
              "All"
            ],
            "type": "string"
          },
          {
            "properties": {
              "AllExcept": {
                "description": "All scopes except these (including those transitively implied).",
                "items": {
                  "$ref": "#/components/schemas/Scope"
                },
                "type": "array"
              }
            },
            "required": [
              "AllExcept"
            ],
            "type": "object"
          },
          {
            "properties": {
              "AllOf": {
                "description": "All of these scopes (including those transitively implied).",
                "items": {
                  "$ref": "#/components/schemas/Scope"
                },
                "type": "array"
              }
            },
            "required": [
              "AllOf"
            ],
            "type": "object"
          }
        ]
      },
      "Seconds": {
        "description": "Duration measured in seconds\nA wrapper type for serialization that encodes a `Duration` as a `u64` representing the number of seconds.",
        "format": "int64",
        "minimum": 0,
        "type": "integer"
      },
      "SignerErrorCode": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/SignerErrorOwnCodes"
          },
          {
            "$ref": "#/components/schemas/AcceptedValueCode"
          },
          {
            "$ref": "#/components/schemas/BadRequestErrorCode"
          },
          {
            "$ref": "#/components/schemas/BadGatewayErrorCode"
          },
          {
            "$ref": "#/components/schemas/NotFoundErrorCode"
          },
          {
            "$ref": "#/components/schemas/ForbiddenErrorCode"
          },
          {
            "$ref": "#/components/schemas/UnauthorizedErrorCode"
          },
          {
            "$ref": "#/components/schemas/PreconditionErrorCode"
          },
          {
            "$ref": "#/components/schemas/TimeoutErrorCode"
          },
          {
            "$ref": "#/components/schemas/ConflictErrorCode"
          },
          {
            "$ref": "#/components/schemas/InternalErrorCode"
          }
        ]
      },
      "SignerErrorOwnCodes": {
        "enum": [
          "PreComputed",
          "StatusCodeWithMessage",
          "JrpcError",
          "UnhandledError",
          "ProxyStartError",
          "EnclaveError"
        ],
        "type": "string"
      },
      "SolanaTxCmp": {
        "properties": {
          "ignore_blockhash": {
            "description": "Whether the 'recent_blockhash' property of the Solana transaction is allowed to be different.",
            "type": "boolean"
          }
        },
        "type": "object"
      },
      "TimeoutErrorCode": {
        "enum": [
          "PolicyEngineTimeout",
          "WasmPolicyExecutionTimeout"
        ],
        "type": "string"
      },
      "UnauthorizedErrorCode": {
        "enum": [
          "AuthorizationHeaderMissing",
          "EndpointRequiresUserSession",
          "RefreshTokenMissing"
        ],
        "type": "string"
      }
    },
    "securitySchemes": {
      "Oidc": {
        "description": "OIDC tokens allow users to authenticate using a third-party service. These are exchanged for signer session tokens.",
        "in": "header",
        "name": "Authorization",
        "type": "apiKey"
      },
      "SignerAuth": {
        "description": "Signing API end-points use session tokens for auth. Specifically, with each request you need to use the \\`token\\` from your signer session (which you create with `cs token create`).",
        "in": "header",
        "name": "Authorization",
        "type": "apiKey"
      }
    }
  },
  "info": {
    "contact": {
      "email": "hello@cubist.dev",
      "name": "Cubist Inc."
    },
    "description": "The CubeSigner management and signing service.",
    "title": "CubeSigner API",
    "version": "v0.125.0"
  },
  "openapi": "3.0.3",
  "paths": {
    "/v0/org/{org_id}/keys/{key_id}": {
      "get": {
        "description": "Get Key\n\nReturns the properties of a key.",
        "operationId": "getKeyInOrg",
        "parameters": [
          {
            "description": "Name or ID of the desired Org",
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a",
            "in": "path",
            "name": "org_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "ID of the desired Key",
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a",
            "in": "path",
            "name": "key_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/KeyInfo"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": ""
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:key:get"
            ]
          }
        ],
        "summary": "Get Key",
        "tags": [
          "Keys"
        ]
      }
    },
    "/v0/org/{org_id}/roles/{role_id}/tokens": {
      "post": {
        "description": "Create Token\n\nCreates a new access token for a given role (to be used as \"API Key\" for all signing actions).\nThe `restricted_actions` field on the [Role] determines the membership role that is required to\ncreate tokens.",
        "operationId": "createRoleToken",
        "parameters": [
          {
            "description": "Name or ID of the desired Org",
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a",
            "in": "path",
            "name": "org_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Name or ID of the desired Role",
            "example": "Role#124dfe3e-3bbd-487d-80c0-53c55e8ab87a",
            "in": "path",
            "name": "role_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateTokenRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": ""
          }
        },
        "security": [
          {
            "SignerAuth": [
              "manage:session:create"
            ]
          }
        ],
        "summary": "Create Token",
        "tags": [
          "Role Access Tokens"
        ]
      }
    },
    "/v1/org/{org_id}/blob/sign/{key_id}": {
      "post": {
        "description": "Sign Raw Blob\n\nSigns an arbitrary blob with a given key.\n\n- ECDSA signatures are serialized as big-endian r and s plus recovery-id\nbyte v, which can in general take any of the values 0, 1, 2, or 3.\n\n- EdDSA signatures are serialized in the standard format.\n\n- BLS signatures are not supported on the blob-sign endpoint.",
        "operationId": "blobSign",
        "parameters": [
          {
            "description": "Name or ID of the desired Org",
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a",
            "in": "path",
            "name": "org_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "ID of the desired Key",
            "example": "Key#124dfe3e-3bbd-487d-80c0-53c55e8ab87a",
            "in": "path",
            "name": "key_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/BlobSignRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/SignResponse"
          },
          "202": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AcceptedResponse"
                }
              }
            },
            "description": ""
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": ""
          }
        },
        "security": [
          {
            "SignerAuth": [
              "sign:blob"
            ]
          }
        ],
        "summary": "Sign Raw Blob",
        "tags": [
          "Signing"
        ]
      }
    },
    "/v1/org/{org_id}/token/refresh": {
      "patch": {
        "description": "Refresh Signer Session",
        "operationId": "signerSessionRefresh",
        "parameters": [
          {
            "description": "ID of the organization owning the key",
            "example": "Org#124dfe3e-3bbd-487d-80c0-53c55e8ab87a",
            "in": "path",
            "name": "org_id",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AuthData"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/NewSessionResponse"
          },
          "default": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            },
            "description": ""
          }
        },
        "security": [
          {
            "SignerAuth": [
              ""
            ]
          }
        ],
        "summary": "Refresh Signer Session",
        "tags": [
          "SignerSession"
        ]
      }
    }
  },
  "security": [
    {
      "Cognito": []
    }
  ],
  "servers": [
    {
      "description": "Testing and staging environment",
      "url": "https://gamma.signer.cubist.dev"
    },
    {
      "description": "Production environment",
      "url": "https://prod.signer.cubist.dev"
    }
  ]
}